 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/backend/src/documents.routes.js b/backend/src/documents.routes.js
index 1d06ce08da9c08329eaf4afba65c816908bf07fa..b8a9cdb420de6e3e4649b625257d99d18282c5f8 100644
--- a/backend/src/documents.routes.js
+++ b/backend/src/documents.routes.js
@@ -191,226 +191,246 @@ function documentsRouter({ requireAuth, upload, getOpenAiKey, proxyOpenAiRequest
       res.status(500).json({ error: "server_error" });
     }
   });
 
   // POST /api/documents/:id/read - start AI read job (PR 9)
   router.post("/api/documents/:id/read", requireAuth, async (req, res) => {
     try {
       const owner_user_id = req.user?.sub;
       const { id } = req.params;
       if (!isValidUuid(id)) return res.status(400).json({ error: "invalid_document_id" });
 
       const { rows } = await pool.query(
         "SELECT * FROM documents WHERE document_id = $1 AND owner_user_id = $2 LIMIT 1",
         [id, owner_user_id]
       );
       if (!rows[0]) return res.status(404).json({ error: "not_found" });
 
       const doc = rows[0];
 
       // Mark as processing
       await pool.query(
         "UPDATE documents SET ai_status = 'reading', ai_error = NULL, ai_updated_at = NOW() WHERE document_id = $1",
         [id]
       );
 
-      // Fire-and-forget AI read
-      processDocumentRead(pool, doc, getOpenAiKey).catch((err) => {
+      let readText = "";
+      try {
+        readText = await processDocumentRead(pool, doc, getOpenAiKey);
+      } catch (err) {
         console.error("AI read job failed for document", id, err);
-      });
+        return res.status(502).json({
+          error: "openai_error",
+          message: String(err && err.message ? err.message : err),
+        });
+      }
 
-      res.json({ status: "reading", document_id: id });
+      res.json({ status: "read_complete", document_id: id, read_text: readText });
     } catch (e) {
       console.error("POST /api/documents/:id/read error", e);
       res.status(500).json({ error: "server_error" });
     }
   });
 
   // POST /api/documents/:id/explain - start AI explain job (PR 9)
   router.post("/api/documents/:id/explain", requireAuth, async (req, res) => {
     try {
       const owner_user_id = req.user?.sub;
       const { id } = req.params;
       if (!isValidUuid(id)) return res.status(400).json({ error: "invalid_document_id" });
 
       const { rows } = await pool.query(
         "SELECT * FROM documents WHERE document_id = $1 AND owner_user_id = $2 LIMIT 1",
         [id, owner_user_id]
       );
       if (!rows[0]) return res.status(404).json({ error: "not_found" });
 
       const doc = rows[0];
 
       if (!doc.read_text) {
         return res.status(400).json({ error: "document_not_read", message: "Run /read first" });
       }
 
       // Mark as processing
       await pool.query(
         "UPDATE documents SET ai_status = 'explaining', ai_error = NULL, ai_updated_at = NOW() WHERE document_id = $1",
         [id]
       );
 
-      // Fire-and-forget AI explain
-      processDocumentExplain(pool, doc, getOpenAiKey).catch((err) => {
+      let explanation = "";
+      try {
+        explanation = await processDocumentExplain(pool, doc, getOpenAiKey);
+      } catch (err) {
         console.error("AI explain job failed for document", id, err);
-      });
+        return res.status(502).json({
+          error: "openai_error",
+          message: String(err && err.message ? err.message : err),
+        });
+      }
 
-      res.json({ status: "explaining", document_id: id });
+      res.json({ status: "complete", document_id: id, owner_explanation: explanation });
     } catch (e) {
       console.error("POST /api/documents/:id/explain error", e);
       res.status(500).json({ error: "server_error" });
     }
   });
 
   // GET /api/documents/:id/status - get AI job status
   router.get("/api/documents/:id/status", requireAuth, async (req, res) => {
     try {
       const owner_user_id = req.user?.sub;
       const { id } = req.params;
       if (!isValidUuid(id)) return res.status(400).json({ error: "invalid_document_id" });
 
       const { rows } = await pool.query(
         `SELECT document_id, ai_status, ai_error, ai_updated_at, read_text IS NOT NULL AS has_read_text,
                 owner_explanation IS NOT NULL AS has_explanation
          FROM documents WHERE document_id = $1 AND owner_user_id = $2 LIMIT 1`,
         [id, owner_user_id]
       );
       if (!rows[0]) return res.status(404).json({ error: "not_found" });
 
       res.json(rows[0]);
     } catch (e) {
       console.error("GET /api/documents/:id/status error", e);
       res.status(500).json({ error: "server_error" });
     }
   });
 
   return router;
 }
 
 /**
  * Background AI read: extracts text from a document image/PDF via OpenAI vision.
  */
 async function processDocumentRead(pool, doc, getOpenAiKey) {
   const oaKey = getOpenAiKey();
   if (!oaKey) {
+    const err = new Error("openai_key_not_configured");
     await pool.query(
       "UPDATE documents SET ai_status = 'error', ai_error = 'openai_key_not_configured', ai_updated_at = NOW() WHERE document_id = $1",
       [doc.document_id]
     );
-    return;
+    throw err;
   }
 
   try {
     const filePath = path.join(getStoragePath(), doc.storage_key);
     const fileBuffer = fs.readFileSync(filePath);
     const base64 = fileBuffer.toString("base64");
     const dataUri = `data:${doc.mime_type};base64,${base64}`;
 
     const payload = {
       model: "gpt-4o",
       messages: [
         {
           role: "system",
           content: "You are a veterinary document reader. Extract all text content from this document. Return only the extracted text, preserving structure where possible.",
         },
         {
           role: "user",
           content: [
             { type: "text", text: "Please read and extract all text from this veterinary document." },
             { type: "image_url", image_url: { url: dataUri } },
           ],
         },
       ],
       max_tokens: 4096,
     };
 
     const response = await fetch("https://api.openai.com/v1/chat/completions", {
       method: "POST",
       headers: {
         Authorization: `Bearer ${oaKey}`,
         "Content-Type": "application/json",
       },
       body: JSON.stringify(payload),
     });
 
     if (!response.ok) {
       const errText = await response.text();
       throw new Error(`OpenAI API error ${response.status}: ${errText}`);
     }
 
     const data = await response.json();
     const readText = data.choices?.[0]?.message?.content || "";
 
     await pool.query(
       "UPDATE documents SET read_text = $2, ai_status = 'read_complete', ai_error = NULL, ai_updated_at = NOW() WHERE document_id = $1",
       [doc.document_id, readText]
     );
+
+    return readText;
   } catch (err) {
     console.error("processDocumentRead error", err);
     await pool.query(
       "UPDATE documents SET ai_status = 'error', ai_error = $2, ai_updated_at = NOW() WHERE document_id = $1",
       [doc.document_id, String(err.message || err).slice(0, 1000)]
     );
+    throw err;
   }
 }
 
 /**
  * Background AI explain: generates a pet-owner-friendly explanation of extracted text.
  */
 async function processDocumentExplain(pool, doc, getOpenAiKey) {
   const oaKey = getOpenAiKey();
   if (!oaKey) {
+    const err = new Error("openai_key_not_configured");
     await pool.query(
       "UPDATE documents SET ai_status = 'error', ai_error = 'openai_key_not_configured', ai_updated_at = NOW() WHERE document_id = $1",
       [doc.document_id]
     );
-    return;
+    throw err;
   }
 
   try {
     const payload = {
       model: "gpt-4o",
       messages: [
         {
           role: "system",
           content: "You are a veterinary assistant. Explain the following veterinary document content to a pet owner in clear, simple language. Highlight any important findings, diagnoses, medications, or follow-up actions.",
         },
         {
           role: "user",
           content: `Please explain this veterinary document to me as a pet owner:\n\n${doc.read_text}`,
         },
       ],
       max_tokens: 2048,
     };
 
     const response = await fetch("https://api.openai.com/v1/chat/completions", {
       method: "POST",
       headers: {
         Authorization: `Bearer ${oaKey}`,
         "Content-Type": "application/json",
       },
       body: JSON.stringify(payload),
     });
 
     if (!response.ok) {
       const errText = await response.text();
       throw new Error(`OpenAI API error ${response.status}: ${errText}`);
     }
 
     const data = await response.json();
     const explanation = data.choices?.[0]?.message?.content || "";
 
     await pool.query(
       "UPDATE documents SET owner_explanation = $2, ai_status = 'complete', ai_error = NULL, ai_updated_at = NOW() WHERE document_id = $1",
       [doc.document_id, explanation]
     );
+
+    return explanation;
   } catch (err) {
     console.error("processDocumentExplain error", err);
     await pool.query(
       "UPDATE documents SET ai_status = 'error', ai_error = $2, ai_updated_at = NOW() WHERE document_id = $1",
       [doc.document_id, String(err.message || err).slice(0, 1000)]
     );
+    throw err;
   }
 }
 
 module.exports = { documentsRouter };
 
EOF
)